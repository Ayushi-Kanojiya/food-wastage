
streamlit==1.37.1
pandas>=2.1.0
SQLAlchemy>=2.0.0
PyMySQL>=1.1.0
altair>=5.0.0



# import streamlit as st
# import pandas as pd
# import altair as alt
# from sqlalchemy import create_engine, text

# st.set_page_config(page_title="Food Wastage Dashboard", page_icon="ðŸ½ï¸", layout="wide")
# st.title("ðŸ½ï¸ Food Wastage Dashboard")
# st.caption("Interactive dashboard powered by MySQL + Streamlit")

# @st.cache_resource
# def get_engine():
#     cfg = st.secrets["mysql"]
#     url = f"mysql+pymysql://{cfg['user']}:{cfg['password']}@{cfg['host']}:{cfg['port']}/{cfg['database']}"
#     engine = create_engine(url, pool_recycle=3600)
#     return engine

# engine = get_engine()

# @st.cache_data(ttl=300, show_spinner=False)
# def run_query(sql: str, params: dict | None = None) -> pd.DataFrame:
#     with engine.connect() as conn:
#         if params:
#             return pd.read_sql(text(sql), conn, params=params)
#         else:
#             return pd.read_sql(sql, conn)

# def kpi_card(label, value):
#     st.metric(label, value)

# # Sidebar filters
# st.sidebar.header("Filters")
# cities_df = run_query("SELECT DISTINCT City FROM providers ORDER BY City;")
# cities = ["All"] + cities_df["City"].dropna().astype(str).tolist()
# city_choice = st.sidebar.selectbox("City (providers)", options=cities, index=0)

# ts_minmax = run_query("SELECT MIN(Timestamp) AS min_ts, MAX(Timestamp) AS max_ts FROM claims_data;")
# min_ts = pd.to_datetime(ts_minmax["min_ts"].iloc[0]) if not ts_minmax.empty else None
# max_ts = pd.to_datetime(ts_minmax["max_ts"].iloc[0]) if not ts_minmax.empty else None
# date_range = None
# if min_ts is not None and max_ts is not None:
#     date_range = st.sidebar.date_input("Claim date range (optional)",
#                                        value=(min_ts.date(), max_ts.date()),
#                                        min_value=min_ts.date(), max_value=max_ts.date())
# date_where = ""
# date_params = {}
# if date_range and isinstance(date_range, tuple) and len(date_range) == 2:
#     date_where = " AND c.Timestamp BETWEEN :start_date AND :end_date "
#     date_params = {"start_date": pd.to_datetime(date_range[0]), "end_date": pd.to_datetime(date_range[1])}

# st.markdown("---")

# # KPIs
# col1, col2, col3, col4 = st.columns(4)
# with col1:
#     total_providers = run_query("SELECT COUNT(*) AS c FROM providers;")["c"].iloc[0]
#     kpi_card("Total Providers", total_providers)
# with col2:
#     total_receivers = run_query("SELECT COUNT(*) AS c FROM receivers;")["c"].iloc[0]
#     kpi_card("Total Receivers", total_receivers)
# with col3:
#     total_listings = run_query("SELECT COUNT(*) AS c FROM food_listings;")["c"].iloc[0]
#     kpi_card("Total Listings", total_listings)
# with col4:
#     total_qty = run_query("SELECT COALESCE(SUM(Quantity),0) AS q FROM food_listings;")["q"].iloc[0]
#     kpi_card("Total Quantity Available", int(total_qty))

# st.markdown("---")

# # 1) Providers & Receivers per City
# st.subheader("Providers & Receivers by City")
# pr_city_sql = '''
#     SELECT city,
#            SUM(CASE WHEN src='provider' THEN cnt ELSE 0 END) AS total_providers,
#            SUM(CASE WHEN src='receiver' THEN cnt ELSE 0 END) AS total_receivers
#     FROM (
#         SELECT City, 'provider' AS src, COUNT(*) AS cnt FROM providers GROUP BY City
#         UNION ALL
#         SELECT City, 'receiver' AS src, COUNT(*) AS cnt FROM receivers GROUP BY City
#     ) t
#     GROUP BY city
#     ORDER BY city;
# '''
# pr_city_df = run_query(pr_city_sql)
# st.dataframe(pr_city_df, use_container_width=True)
# if not pr_city_df.empty:
#     pr_long = pr_city_df.melt(id_vars="city", var_name="role", value_name="count")
#     chart = alt.Chart(pr_long).mark_bar().encode(
#         x=alt.X("city:N", sort="-y", title="City"),
#         y=alt.Y("count:Q", title="Count"),
#         color=alt.Color("role:N", title="Type")
#     ).properties(height=320)
#     st.altair_chart(chart, use_container_width=True)

# st.markdown("---")

# # 2) Provider type contributing most food
# st.subheader("Quantity by Provider Type")
# qty_by_type = run_query("""
#     SELECT Provider_Type, SUM(Quantity) AS total_quantity
#     FROM food_listings
#     GROUP BY Provider_Type
#     ORDER BY total_quantity DESC;
# """)
# st.dataframe(qty_by_type, use_container_width=True)
# if not qty_by_type.empty:
#     chart2 = alt.Chart(qty_by_type).mark_bar().encode(
#         x=alt.X("Provider_Type:N", sort="-y", title="Provider Type"),
#         y=alt.Y("total_quantity:Q", title="Total Quantity")
#     ).properties(height=320)
#     st.altair_chart(chart2, use_container_width=True)

# st.markdown("---")

# # 3) Contact info in selected city
# st.subheader("Provider Contacts by City")
# contacts_sql = "SELECT Name, Contact FROM providers {where} ORDER BY Name;"
# where_clause = ""
# params = {}
# if city_choice != "All":
#     where_clause = "WHERE City = :city"
#     params["city"] = city_choice
# contacts_df = run_query(contacts_sql.format(where=where_clause), params=params if params else None)
# st.dataframe(contacts_df, use_container_width=True)

# st.markdown("---")

# # 4) Top receivers by claims
# st.subheader("Top Receivers by Claims")
# top_receivers_sql = f"""
#     SELECT r.Name AS Receiver_Name,
#            COUNT(c.Claim_ID) AS claim_count,
#            COALESCE(SUM(f.Quantity),0) AS approx_total_qty
#     FROM claims_data c
#     JOIN receivers r ON c.Receiver_ID = r.Receiver_ID
#     JOIN food_listings f ON c.Food_ID = f.Food_ID
#     WHERE 1=1 {date_where}
#     GROUP BY r.Name
#     ORDER BY claim_count DESC, approx_total_qty DESC
#     LIMIT 20;
# """
# top_receivers_df = run_query(top_receivers_sql, params=date_params if date_params else None)
# st.dataframe(top_receivers_df, use_container_width=True)
# if not top_receivers_df.empty:
#     chart3 = alt.Chart(top_receivers_df).mark_bar().encode(
#         x=alt.X("Receiver_Name:N", sort="-y", title="Receiver"),
#         y=alt.Y("claim_count:Q", title="Claims")
#     ).properties(height=320)
#     st.altair_chart(chart3, use_container_width=True)

# st.markdown("---")

# # 5) Total quantity available
# st.subheader("Total Quantity Available")
# qty_df = run_query("SELECT COALESCE(SUM(Quantity),0) AS total_qty FROM food_listings;")
# st.metric("Total Available Quantity", int(qty_df['total_qty'].iloc[0]))

# st.markdown("---")

# # 6) City with highest number of food listings
# st.subheader("Food Listings by City (Provider's City)")
# listings_city_sql = '''
#     SELECT p.City, COUNT(f.Food_ID) AS total_listings
#     FROM food_listings f
#     JOIN providers p ON f.Provider_ID = p.Provider_ID
#     GROUP BY p.City
#     ORDER BY total_listings DESC;
# '''
# listings_city_df = run_query(listings_city_sql)
# st.dataframe(listings_city_df, use_container_width=True)
# if not listings_city_df.empty:
#     chart4 = alt.Chart(listings_city_df).mark_bar().encode(
#         x=alt.X("City:N", sort="-y", title="City"),
#         y=alt.Y("total_listings:Q", title="Listings")
#     ).properties(height=320)
#     st.altair_chart(chart4, use_container_width=True)

# st.markdown("---")

# # 7) Most common food types
# st.subheader("Most Common Food Types")
# types_df = run_query("""
#     SELECT Food_Type, COUNT(*) AS total_items
#     FROM food_listings
#     GROUP BY Food_Type
#     ORDER BY total_items DESC;
# """)
# st.dataframe(types_df, use_container_width=True)
# if not types_df.empty:
#     chart5 = alt.Chart(types_df).mark_bar().encode(
#         x=alt.X("Food_Type:N", sort="-y", title="Food Type"),
#         y=alt.Y("total_items:Q", title="Count")
#     ).properties(height=320)
#     st.altair_chart(chart5, use_container_width=True)

# st.markdown("---")

# # 8) Claims per food item
# st.subheader("Claims per Food Item")
# claims_per_food_sql = f"""
#     SELECT f.Food_Name, COUNT(c.Claim_ID) AS total_claims
#     FROM claims_data c
#     JOIN food_listings f ON c.Food_ID = f.Food_ID
#     WHERE 1=1 {date_where}
#     GROUP BY f.Food_Name
#     ORDER BY total_claims DESC
#     LIMIT 30;
# """
# claims_per_food_df = run_query(claims_per_food_sql, params=date_params if date_params else None)
# st.dataframe(claims_per_food_df, use_container_width=True)
# if not claims_per_food_df.empty:
#     chart6 = alt.Chart(claims_per_food_df).mark_bar().encode(
#         x=alt.X("Food_Name:N", sort="-y", title="Food"),
#         y=alt.Y("total_claims:Q", title="Claims")
#     ).properties(height=320)
#     st.altair_chart(chart6, use_container_width=True)

# st.markdown("---")

# # 9) Provider with highest number of successful claims
# st.subheader("Top Providers by Successful Claims")
# provider_success_sql = f"""
#     SELECT p.Name AS Provider_Name,
#            COUNT(c.Claim_ID) AS successful_claims
#     FROM claims_data c
#     JOIN food_listings f ON c.Food_ID = f.Food_ID
#     JOIN providers p ON f.Provider_ID = p.Provider_ID
#     WHERE c.Status = 'Completed' {date_where}
#     GROUP BY p.Name
#     ORDER BY successful_claims DESC
#     LIMIT 20;
# """
# provider_success_df = run_query(provider_success_sql, params=date_params if date_params else None)
# st.dataframe(provider_success_df, use_container_width=True)
# if not provider_success_df.empty:
#     chart7 = alt.Chart(provider_success_df).mark_bar().encode(
#         x=alt.X("Provider_Name:N", sort="-y", title="Provider"),
#         y=alt.Y("successful_claims:Q", title="Completed Claims")
#     ).properties(height=320)
#     st.altair_chart(chart7, use_container_width=True)

# st.markdown("---")

# # 10) Claim status distribution (percentage)
# st.subheader("Claim Status Distribution")
# status_df = run_query(f"SELECT Status, COUNT(*) AS cnt FROM claims_data c WHERE 1=1 {date_where} GROUP BY Status;",
#                       params=date_params if date_params else None)
# total_claims = int(status_df["cnt"].sum()) if not status_df.empty else 0
# if total_claims > 0:
#     status_df["percentage"] = (status_df["cnt"] / total_claims) * 100
# st.dataframe(status_df, use_container_width=True)
# if not status_df.empty:
#     chart8 = alt.Chart(status_df).mark_arc().encode(
#         theta=alt.Theta(field="cnt", type="quantitative"),
#         color=alt.Color(field="Status", type="nominal"),
#         tooltip=["Status", "cnt", alt.Tooltip("percentage:Q", format=".1f")]
#     ).properties(height=320)
#     st.altair_chart(chart8, use_container_width=True)

# st.markdown("---")

# # 11) Average quantity claimed per receiver (approx. via listing qty)
# st.subheader("Average Quantity Claimed per Receiver (Approx)")
# avg_claim_sql = f"""
#     SELECT r.Name AS Receiver_Name,
#            AVG(f.Quantity) AS avg_qty_claimed
#     FROM claims_data c
#     JOIN receivers r ON c.Receiver_ID = r.Receiver_ID
#     JOIN food_listings f ON c.Food_ID = f.Food_ID
#     WHERE 1=1 {date_where}
#     GROUP BY r.Name
#     ORDER BY avg_qty_claimed DESC
#     LIMIT 20;
# """
# avg_claim_df = run_query(avg_claim_sql, params=date_params if date_params else None)
# st.dataframe(avg_claim_df, use_container_width=True)
# if not avg_claim_df.empty:
#     chart9 = alt.Chart(avg_claim_df).mark_bar().encode(
#         x=alt.X("Receiver_Name:N", sort="-y", title="Receiver"),
#         y=alt.Y("avg_qty_claimed:Q", title="Average Qty")
#     ).properties(height=320)
#     st.altair_chart(chart9, use_container_width=True)

# st.markdown("---")

# # 12) Most claimed meal type
# st.subheader("Most Claimed Meal Types")
# meal_claim_sql = f"""
#     SELECT f.Meal_Type, COUNT(c.Claim_ID) AS total_claims
#     FROM claims_data c
#     JOIN food_listings f ON c.Food_ID = f.Food_ID
#     WHERE 1=1 {date_where}
#     GROUP BY f.Meal_Type
#     ORDER BY total_claims DESC;
# """
# meal_claim_df = run_query(meal_claim_sql, params=date_params if date_params else None)
# st.dataframe(meal_claim_df, use_container_width=True)
# if not meal_claim_df.empty:
#     chart10 = alt.Chart(meal_claim_df).mark_bar().encode(
#         x=alt.X("Meal_Type:N", sort="-y", title="Meal Type"),
#         y=alt.Y("total_claims:Q", title="Claims")
#     ).properties(height=320)
#     st.altair_chart(chart10, use_container_width=True)

# st.markdown("---")

# # 13) Total quantity donated by each provider
# st.subheader("Total Quantity Donated by Provider")
# donated_sql = '''
#     SELECT p.Name AS Provider_Name,
#            SUM(f.Quantity) AS total_donated
#     FROM food_listings f
#     JOIN providers p ON f.Provider_ID = p.Provider_ID
#     GROUP BY p.Name
#     ORDER BY total_donated DESC
#     LIMIT 30;
# '''
# donated_df = run_query(donated_sql)
# st.dataframe(donated_df, use_container_width=True)
# if not donated_df.empty:
#     chart11 = alt.Chart(donated_df).mark_bar().encode(
#         x=alt.X("Provider_Name:N", sort="-y", title="Provider"),
#         y=alt.Y("total_donated:Q", title="Total Donated")
#     ).properties(height=320)
#     st.altair_chart(chart11, use_container_width=True)

# st.caption("Use the left sidebar to filter city and date range. Data is cached for 5 minutes.")
